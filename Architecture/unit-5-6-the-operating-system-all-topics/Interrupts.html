<div id="jsn-maincontent" class="span9 order1  row-fluid">
					<div id="jsn-maincontent_inner">
						<div id="jsn-centercol"><div id="jsn-centercol_inner">
									<div id="jsn-mainbody-content" class=" jsn-hasmainbody">
								<div id="jsn-mainbody-content-inner1"><div id="jsn-mainbody-content-inner2"><div id="jsn-mainbody-content-inner3"><div id="jsn-mainbody-content-inner4" class="row-fluid">
								
										
								
								<div id="jsn-mainbody-content-inner" class="span12 order1 ">
		
										<div id="jsn-mainbody">
										<div id="system-message-container">
	</div>

										<div class="item-page" itemscope itemtype="https://schema.org/Article">
	<meta itemprop="inLanguage" content="en-GB" >
	
		
						
		
	
	
		
								<div itemprop="articleBody">
		<p></p>
<h1 style="text-align: center;">Interrupts</h1>
<p><strong class="NormalContentHeading">Applications of interrupts</strong><br> Interrupts are signals generated by a hardware device or by a software application that tell the CPU it needs some CPU time. A CPU can only ever do one job at a time. If it is working on one job and another job needs some CPU processing time then that other job sends a signal, an interrupt, to the processor. When the processor receives the signal, it does one of a number of things.</p>
 
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: disc;">
<li>The CPU might stop what it is doing and start servicing the device or software that sent the signal.</li>
<li>The CPU might carry on doing its current job until it is finished and then service the device or software that sent the signal.</li>
<li>The CPU might carry on doing its current job and then service other interrupts that have happened. When it has done those, it then services the interrupt in our discussion!</li>
</ul>
</li>
</ul>
<p>To summarise, an interrupt is a signal sent to the CPU by a device or by a program that indicates to the CPU that a device or program needs some 'CPU time'. The CPU must stop what it is doing and run a program, a piece of software, for that particular type of interrupt, known as an <strong>interrupt handling routine</strong>. The first decision the CPU must make is when to run the interrupt handling routine - how urgent is it compared to what it is currently doing and compared to what else is waiting to be done!</p>
<p class="NormalContentHeading"><strong>Different kinds of interrupts</strong></p>
<p align="center"><img src="images/9793c73c-1514-4dd2-8d17-3c64744d305da.gif" alt="interrupts"></p>
<p><strong class="NormalContentHeading">1) A timer interrupt</strong><br> This is an interrupt that occurs at fixed time intervals. There are circuits in a computer that can generate an interrupt signal every 1 ms, for example. This could then be used to signal to the CPU to refresh the VDU, for example.</p>
<p><strong class="NormalContentHeading" style="line-height: 1.5;">2) A program error interrupt</strong></p>
<p>When a program is written, it may need to do maths sums! If you divide any number by zero, the result is meaningless and the program you are running will get confused! The CPU needs to know about this so a 'program error' interrupt signal is sent to the CPU to tell it what has happened. The CPU can then take action, for example, by ending the program and reporting the error.</p>
<p><strong class="NormalContentHeading">3) A hardware error interrupt</strong><br> Your computer is made up of a lot of different hardware devices. Generally, they work well and do what they are supposed to do. But like any electrical or mechanical device they will one day fail. When that happens, the CPU needs to know about it. A device that has failed sends an interrupt signal to the CPU. The CPU can then, for example, put a message on the screen to notify the user of the problem.</p>
<p><strong class="NormalContentHeading">4) I/O interrupts</strong><br> When a file is sent to a printer, it will go to a buffer. The buffer will then communicate with the printer. The reason for this is that it frees up the CPU to do other jobs. Remember, the CPU can only do one job at a time. If it is managing the printing of a file, it can't be doing other things. This, however, isn't a very efficient use of CPU time because printing is slow compared to the speed CPUs work at. We have discussed this in great detail in a previous chapter.</p>
<p>Sometimes, the file that you want to print can't fit into the whole of the buffer. You can remind yourself about the transfer of data using buffers in another chapter.</p>
<p>Another example of an I/O interrupt is the one generated every time you press a key on the keyboard. When you press a key, an interrupt is sent to the CPU. The CPU stops what it is doing and then manages the reading in of the key code into a buffer. Then it goes back to doing what it was doing before. At some point, the CPU will return to the keyboard buffer and retrieve the contents for use somewhere.</p>
<p><strong class="NormalContentHeading">How does the Interrupt process work?</strong><br> The CPU has a special register called the 'interrupt register'. You can imagine this, for example, as a two-byte number (in other words, 16 bits). When a particular interrupt happens, the signal sent causes the correct bit in the interrupt register to be made a 'one'. Here is an example.</p>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: disc;">
<li>This is the interrupt register: 0000 0000 0000 0000</li>
<li>The floppy disk drive fails, so a 'hardware failure' interrupt signal is sent to the interrupt register.</li>
<li>The bit that is used to signal hardware failure is bit 3 so that bit is set to one. (The bit on the right-most side, the least significant bit, is bit zero.)</li>
<li>The interrupt register now looks like this: 0000 0000 0000 1000</li>
</ul>
</li>
</ul>
<p class="NormalContentHeading"><strong>So what happens next?</strong></p>
<ul style="list-style-type: disc;">
<li style="list-style-type: none;">
<ul style="list-style-type: disc;">
<li>At the beginning of each FDE cycle, each bit in the interrupt register is checked in turn.</li>
<li>If a bit has been set, that would indicate an interrupt has happened.</li>
<li>The CPU decides whether to service the interrupt immediately, or leave it till later. For example, if 2 interrupts have happened at the same time, one of them has to wait! Which one? That depends upon which one is the least important! Some interrupts are more important than others and so need to be done before others. What about the situation where one interrupt is currently being serviced by the CPU and another happens? Again, it depends on how important the new interrupt is compared to the one already being done. If it is more important, then the CPU will want to service it immediately.</li>
<li>When the CPU decides to service an interrupt, it stops processing the current job, 'pushing' the contents of its registers onto the stack. This would include, for example, the contents of the Program Counter and the Accumulator. The CPU is now free to work on another piece of software but can return to what it was doing after the interrupt has been serviced because it has saved where it was.</li>
<li>It then transfers control to the interrupt handling software for that type of interrupt. You can read more about how it does that (using the Vectored Interrupt Mechanism) later in this chapter.</li>
<li>When it has finished servicing the interrupt, the contents of the stack are 'popped' back into the appropriate registers and the CPU continues from where it left off before the interrupt happened.</li>
</ul>
</li>
</ul>
<p><strong class="NormalContentHeading">More on the prioritisation of interrupts</strong><br> A computer needs to make a decision! It has to decide what priority to give each of the different kinds of interrupts, in case it has to service more than one kind of interrupt simultaneously. One possible order is shown below. I have decided that the most important kind of interrupt is the hardware failure interrupt. If anything fails, I want the computer to stop what it is doing immediately and service it - attempt to sort out the problem and also tell me about it. I have equally decided that I/O requests are the least important interrupts and can be serviced last if a choice between which interrupt to service has to be made.</p>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: disc;">
<li>Hardware failure: Priority 1 (most important)</li>
<li>Program error: Priority 2</li>
<li>Timer: Priority 3</li>
<li>I/O: Priority 4</li>
</ul>
</li>
</ul>
<p><strong class="NormalContentHeading">The Vectored Interrupt Mechanism</strong><br> When an interrupt happens, the CPU needs to jump to the relevant software routine. How does it know where it is? It can do this by using a technique known as 'indirect addressing'. This is fully explained in the chapter on low-level languages but briefly, when an interrupt happens, the CPU identifies what kind of interrupt it is. With every type of interrupt, there is an associated memory address, known as a <strong>vector</strong>. This memory address, or vector, holds the address of the relevant interrupt handling routine. So when an interrupt happens, the CPU jumps to the vector, gets the address of the start of the interrupt handling routine, loads it into the Program Counter and processing continues. For example:</p>
<ul>
<li style="list-style-type: none;">
<ul style="list-style-type: disc;">
<li>The CPU is working on a word processing application. The interrupt register is 0000 0000 0000 0000.</li>
<li>A software error occurs that causes a program error interrupt to occur.</li>
<li>Bit 6, used for program error interrupts, is set. The interrupt register is now 0000 0000 0100 0000</li>
<li>At the start of the FDE cycle, the interrupt register is checked and the CPU sees that an error has occurred.</li>
<li>It isn't currently servicing any other interrupt and no other higher priority interrupt has occurred so it decides to service this routine.</li>
<li>It pushes the contents of the CPU’s registers onto the stack.</li>
<li>It jumps to the address (known as a vector) for that type of interrupt.</li>
<li>At that vector address, it finds another address!</li>
<li>It loads that address into the Program Counter.</li>
<li>The interrupt routine completes.</li>
<li>The contents of the stack are popped into the CPU's registers.</li>
<li>The CPU continues doing whatever it was doing before the interrupt happened.</li>
</ul>
</li>
</ul>
<p></p>	</div>

	
							</div>

									</div>
				
							</div>
							
				        							
							
							</div></div></div></div></div>			
							
							
		        				</div></div> 
				</div></div>